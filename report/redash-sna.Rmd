---
title: "Complex social graphs in repositories"
author: "JJ Merelo"
date: "13 de febrero de 2017"
output: html_document
bibliography: biblio.bib
---

##Abstract

>There is no single *natural* way of analyzing the graph created by the collaborative work of a team of software developers as reflected in the log of that repository. In this paper we will analyze several graphs created by this work, considering author or files the nodes in what is actually a bipartite network. We will try to find out which network better represents the complex nature of the technosocial system.

```{r setup, echo=FALSE}
library("igraph")

# from http://stackoverflow.com/questions/5643002/r-selectively-display-nodes-when-plotting-an-igraph
delete.isolates <- function(graph) {
  bad.vs<-V(graph)[degree(graph) == 0]
  delete.vertices(graph, bad.vs)
}
beehive.author.net <- read_graph(file = "../data/sna/author-beehive.net", format = 'pajek')
beehive.author.net.core <- as.undirected(delete.isolates(beehive.author.net), mode='each')
beehive.files.net <- read_graph(file = "../data/sna/files-beehive.net", format = 'pajek')
beehive.files.net.core <- as.undirected(delete.isolates(beehive.files.net), mode='each')
beehive.commit.net <- read_graph(file = "../data/sna/commit-beehive.net", format = 'pajek')
beehive.commit.net.core <- as.undirected(delete.isolates(beehive.commit.net), mode='each')

```

# Introduction

Beehive is a Go event and agent system available with a free license from https://github.com/muesli/beehive.

The repository can be represented as a bipartite graph with authors and files, with non-directed edges connecting authors with those files they have worked on. There are several possible ways of turning this bipartite graph into a one-party graph: create a graph of files joined by one edge if they have one developer in common, or joining authors by one edge if they have worked on at least one file. In this report our objective is to present a methodology to mine the social aspects of software repositories and some initial results, showing its strenghts and its limitations.

# Mining repository information

What every software project has in common is the history contained in the source control management log. This information can be extracted from the repository, once it has been downloaded, using `git log`. This command gives information on the files that have been changed during that commit, size and places where those changes have taken place, and the author of the commit. Although a commit might include work from several authors at once, if it is combined in a single change set the author will be the one that has actually merged the change set in a single commit; it all boils down to a commit including a single author and one or more files. After establishing the self-organized criticality of some repos examining these commit logs in papers such as @merelo16:self

```{r plot, echo=FALSE}
plot(beehive.author.net.core,vertex.size=betweenness(beehive.author.net.core)/10,vertex.label=NA,layout = layout.fruchterman.reingold,vertex.color=closeness(beehive.author.net.core),palette=diverging_pal(11))
plot(beehive.files.net.core)
```

However, the file graph is not entirely satisfactory since, in fact, the main developer might have touched all files, and, second, files completely unrelated might be joined since they are created or modified sequentially by the same developer. 


```{r commit, echo=FALSE}
plot(beehive.commit.net.core,vertex.size=betweenness(beehive.commit.net.core)/500,vertex.label=NA,layout = layout.fruchterman.reingold,vertex.color=closeness(beehive.author.net.core)*10,palette=diverging_pal(11))
```

# References